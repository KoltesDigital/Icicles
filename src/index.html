<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf8">
    <!--
    @license twgl.js Copyright (c) 2015, Gregg Tavares All Rights Reserved.
    Available via the MIT license.
    see: http://github.com/greggman/twgl.js for details
    -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

    <title>twgl.js - twgl cube</title>
    <style>
      body {
          margin: 0;
          font-family: monospace;
      }
      canvas {
          display: block;
          width: 100vw;
          height: 100vh;
      }
      #b {
        position: absolute;
        top: 10px;
        width: 100%;
        text-align: center;
        z-index: 2;
      }
    </style>
  </head>
  <body>
    <canvas id="c"></canvas>
  </body>







  <script id="vs" type="notjs">
// hash based 3d value noise
// function taken from https://www.shadertoy.com/view/XslGRr
// Created by inigo quilez - iq/2013
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// ported from GLSL to HLSL
float hash( float n )
{
  return fract(sin(n)*43758.5453);
}

float noiseIQ( vec3 x )
{
  // The noise function returns a value in the range -1.0f -> 1.0f
  vec3 p = floor(x);
  vec3 f = fract(x);
  f       = f*f*(3.0-2.0*f);
  float n = p.x + p.y*57.0 + 113.0*p.z;
  return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),
   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),
  mix(mix( hash(n+113.0), hash(n+114.0),f.x),
   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

vec3 rotateY(vec3 v, float t)
{
  float cost = cos(t); float sint = sin(t);
  return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);
}

vec3 rotateX(vec3 v, float t)
{
  float cost = cos(t); float sint = sin(t);
  return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);
}

vec3 rotateZ(vec3 p, float angle)
{
  float c = cos(angle);
  float s = sin(angle);
  return vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);
}

uniform mat4 u_worldViewProjection;
uniform vec3 u_lightWorldPos;
uniform mat4 u_world;
uniform mat4 u_viewInverse;
uniform mat4 u_worldInverseTranspose;
uniform float u_time;

attribute vec4 a_position;
attribute vec4 a_color;
attribute vec3 a_normal;
attribute vec2 a_texcoord;

varying vec4 v_position;
varying vec4 v_color;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

vec3 displaceWave (vec3 p)
{
  p.y += sin(length(p) * 0.3 - u_time) * 4.;
  p.y *= 1. - clamp(length(p.xyz)*0.02,0.,1.);
  return p;
}

vec3 getOffset ()
{
  // return vec3(0);
  return vec3(u_time * 10. + 1000.,0,0);
}

vec3 displace (vec3 p)
{
  vec3 offset = getOffset();
  p.y += noiseIQ((p + offset) * 0.03) * 3.;
  p.y += noiseIQ((p + offset) * 0.07) * 6.;
  return p;
}

float kaleido (float d)
{
  float dMod = mod(abs(d), 1.0);
  return mix(1.0 - dMod, dMod, mod(floor(abs(d)), 2.0));
}

void main() {
  v_color = a_color;
  vec4 p = a_position;
  p.xyz = displace(p.xyz);
  // p.y *= length

  float neighbor = 1.;
  vec3 north = displace(p.xyz + vec3(0,0,neighbor));
  vec3 south = displace(p.xyz + vec3(0,0,-neighbor));
  vec3 east = displace(p.xyz + vec3(neighbor,0,0));
  vec3 west = displace(p.xyz + vec3(-neighbor,0,0));
  vec3 normal = cross(normalize(south - north), normalize(west - east));

  // p.xyz -= normalize(vec3(normal.x,0,normal.z));

  v_position = (u_worldViewProjection * p);
  v_normal = (u_worldInverseTranspose * vec4(normal, 0)).xyz;
  v_surfaceToLight = u_lightWorldPos - (u_world * p).xyz;
  v_surfaceToView = (u_viewInverse[3] - (u_world * p)).xyz;
  gl_Position = v_position;

  float uvScale = 0.005;
  p.xyz += getOffset();
  v_texCoord = mod(abs(p.xz*uvScale), 1.);
}
  </script>
  <script id="fs" type="notjs">
precision mediump float;

varying vec4 v_position;
varying vec4 v_color;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToView;

uniform vec4 u_lightColor;
uniform vec4 u_ambient;
uniform sampler2D u_diffuse;
uniform sampler2D u_groundTexture;
uniform vec4 u_specular;

float luminance ( vec3 color ) {  return (color.r + color.g + color.b) / 3.0; }
vec3 posterize ( vec3 color, float details ) {  return ceil(color * details) / details; }
float segment ( float value, float details ) {  return ceil(value * details) / details; }

void main() {
  vec4 diffuseColor = texture2D(u_diffuse, v_texCoord);
  vec3 a_normal = normalize(v_normal);
  vec3 surfaceToView = normalize(v_surfaceToView);
  float litR = dot(a_normal, -surfaceToView) * 0.5 + 0.5;
  // gl_FragColor = outColor;
  // gl_FragColor = vec4(a_normal * 0.5 + 0.5, 1);
  vec3 green = vec3(0.55, 0.82, 0.35);
  vec3 brown = vec3(0.81, 0.56, 0.28);
  // vec3 ground = texture2D(u_groundTexture, v_texCoord).rgb;
  vec3 color = mix(green, brown, dot(a_normal, vec3(0,0,1)) * 2.);
  // litR = segment(litR, 32.);
  gl_FragColor = vec4(color * litR, 1);
}
  </script>





  <script id="vsParticle" type="notjs">
// hash based 3d value noise
// function taken from https://www.shadertoy.com/view/XslGRr
// Created by inigo quilez - iq/2013
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.

// ported from GLSL to HLSL
float hash( float n )
{
  return fract(sin(n)*43758.5453);
}

float noiseIQ( vec3 x )
{
  // The noise function returns a value in the range -1.0f -> 1.0f
  vec3 p = floor(x);
  vec3 f = fract(x);
  f       = f*f*(3.0-2.0*f);
  float n = p.x + p.y*57.0 + 113.0*p.z;
  return mix(mix(mix( hash(n+0.0), hash(n+1.0),f.x),
   mix( hash(n+57.0), hash(n+58.0),f.x),f.y),
  mix(mix( hash(n+113.0), hash(n+114.0),f.x),
   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);
}

vec3 rotateY(vec3 v, float t)
{
  float cost = cos(t); float sint = sin(t);
  return vec3(v.x * cost + v.z * sint, v.y, -v.x * sint + v.z * cost);
}

vec3 rotateX(vec3 v, float t)
{
  float cost = cos(t); float sint = sin(t);
  return vec3(v.x, v.y * cost - v.z * sint, v.y * sint + v.z * cost);
}

vec3 rotateZ(vec3 p, float angle)
{
  float c = cos(angle);
  float s = sin(angle);
  return vec3(c*p.x+s*p.y, -s*p.x+c*p.y, p.z);
}

uniform mat4 u_worldViewProjection;
uniform vec3 u_lightWorldPos;
uniform mat4 u_world;
uniform mat4 u_viewInverse;
uniform mat4 u_worldInverseTranspose;
uniform float u_time;

attribute vec4 a_position;
attribute vec4 a_color;
attribute vec3 a_normal;
attribute vec2 a_texcoord;

varying vec4 v_position;
varying vec4 v_color;
varying vec2 v_texCoord;
varying vec3 v_normal;
varying vec3 v_surfaceToLight;
varying vec3 v_surfaceToView;

vec3 displaceWave (vec3 p)
{
  p.y += sin(length(p) * 0.3 - u_time) * 4.;
  p.y *= 1. - clamp(length(p.xyz)*0.02,0.,1.);
  return p;
}

vec3 getOffset ()
{
  // return vec3(0);
  return vec3(u_time * 10. + 1000.,0,0);
}

vec3 displace (vec3 p)
{
  vec3 offset = getOffset();
  p.y += noiseIQ((p + offset) * 0.03) * 3.;
  p.y += noiseIQ((p + offset) * 0.07) * 6.;
  return p;
}

void main() {
  v_color = a_color;
  vec4 p = a_position;
  // p.xz = p.xz * 2. - 1.;
  p.xz -= 0.5;
  p.xz *= 100.;
  // p.xyz += getOffset();
  // float size = 10. * noiseIQ(p.xyz * 0.1);
  float size = 8.;
  float ratio = (p.x / 10.) + p.z * 0.02;
  p.xyz += getOffset();
  p.x = mod(abs(p.x), 100.) - 50.;
  p.x *= -1.;
  size *= sin(ratio * 3.14159) * 0.5 + 0.5;
  vec3 offset = vec3(a_texcoord.x * 0.4, a_texcoord.y, 0) * size;
  p.xyz = displace(p.xyz);
  // p.y += 0.1;

  v_position = (u_worldViewProjection * p);
  v_position.xyz += offset;
  // v_position = vec4(p.xzy + offset, sin(u_time));
  gl_Position = v_position;
}
  </script>

  <script id="fsParticle" type="notjs">
precision mediump float;

varying vec4 v_position;
varying vec4 v_color;

float luminance ( vec3 color ) {  return (color.r + color.g + color.b) / 3.0; }
vec3 posterize ( vec3 color, float details ) {  return ceil(color * details) / details; }
float segment ( float value, float details ) {  return ceil(value * details) / details; }

void main() {
  // vec3 a_normal = normalize(v_normal);
  // vec3 surfaceToView = normalize(v_surfaceToView);
  // float litR = dot(a_normal, -surfaceToView) * 0.5 + 0.5;
  // gl_FragColor = outColor;
  // gl_FragColor = vec4(a_normal * 0.5 + 0.5, 1);
  // vec3 green = vec3(0.55, 0.82, 0.35);
  // vec3 brown = vec3(0.81, 0.56, 0.28);
  // vec3 ground = texture2D(u_groundTexture, v_texCoord).rgb;
  // vec3 color = mix(green, brown, dot(a_normal, vec3(0,0,1)) * 2.);
  // litR = segment(litR, 32.);
  vec3 green = vec3(0.55, 0.82, 0.35);
  gl_FragColor = vec4(green, 1);
}
  </script>









  <script src="libs/twgl-full.min.js"></script>
  <script src="scripts/geometry/simple.js"></script>
  <script src="scripts/geometry/particles.js"></script>
  <script src="scripts/main.js"></script>
</html>


